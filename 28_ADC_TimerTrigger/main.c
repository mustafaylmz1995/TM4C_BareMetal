#include "TM4C129.h"                    // Device header

#define micro	1U
#define mili 	1000U
#define sec		1000000U

void enable_clk(void);
void Timer0_init(void);
void sample_seq_conf(void);

unsigned int result;
unsigned int cleared;
unsigned int temperature;

int main(){

	enable_clk();

	sample_seq_conf();
	
	Timer0_init();
	
	
	while(1){
				
		ADC0->PSSI |= (1U<<3); //Provides a mechanism for application software to initiate sampling in the sample sequencers (SS3 Initiate)
		
		while( !((ADC0->RIS & (1U<<3)) == (1U<<3)) ){}; //shows the status of the raw interrupt signal of each sample sequencer(SS3 Raw Interrupt Status)
			
		result = ADC0->SSFIFO3 & 0xFFF; //Contains the conversion results for samples collected with the sample sequencer
		
		temperature = (unsigned int)(147.5 - ((75*3.3) * result) / 4096);
			
		TIMER0->ICR = 0x01;
		cleared = TIMER0->ICR; //a read to force clearing if irq flag
			
		ADC0->ISC = (1U<<3);	//Provides to clear SS IRQ conditions and shows the status of IRQs generated by the SS (SS3 Interrupt Status and Clear)
		cleared = ADC0->ISC;
		
	}
	
}

void enable_clk(void){

	SYSCTL->RCGCADC	 	|= (1U<<0);		//Enable clk for ADC module 0
	while((SYSCTL->PRADC & (1U<<0)) != (1U<<0)) {}; //whether the ADC modules are ready to be accessed by software
	
	SYSCTL->RCGCTIMER |= (1U<<0); //Enable and provide a clock to 16/32-bit general-purpose timer module 0 in Run mode.
	while( ((SYSCTL->PRTIMER) & (1U<<0)) != (1U<<0) ) {}; //Allow time to finish activating
	
}

void Timer0_init(void){
	
	TIMER0->CTL  &= ~(1U<<0); // TAEN 0. bit and TBEN 8. bit

	//For a 16/32-bit timer, this value selects the 32-bit timer configuration.
	TIMER0->CFG = 0x00; 
		
	TIMER0->TAMR = 0x2; //for Periodic mode.
	TIMER0->TAILR = 16000000; //Load the start value into the GPTM Timer n Interval Load Register (GPTMTnILR). (1 sec)

	TIMER0->ICR = 0x01;// TBTOCINT 8. bit and TATOCINT 0. bit for clearing interupt controller register
		
	TIMER0->CTL  |= (1U<<5); // TAOTE 5. bit ADC trigger is enabled
		
	TIMER0->ADCEV |= (1U<<0); //Triggers the ADC at timeout 
	
	TIMER0->CTL  |= (1U<<0); // TAEN 0. bit and TBEN 8. bit	
	
}


void sample_seq_conf(void){
	
	ADC0->ACTSS 			&=~(1U<<3);		//Disable Sample Sequencer 3 (SS3)	(Step 1)		
	
	ADC0->EMUX				= (0x5EEE);		//Selects the event (trigger) that initiates (Step 2)
																	//sampling for each sample sequencer
																	//SS3 Trigger Select Third Nibble 
																	//The trigger is initiated by setting the SSn 
																	//bit in the ADCPSSI register
	
	ADC0->SSMUX3			=		0;				//Get inout from channel 0 (Step 4) PE3 which is analog input 0 AIN0
																	//First Sample Input Select
	ADC0->SSEMUX3			=		0;				//Extra 4 bit wide for SSMUX3
	
	ADC0->SSCTL3			|= ((1U<<1)| (1U<<2) | (1U<<3));	//Take one sample at a time, set flat at 1st sample (Step5)
																					// 3 	 2 	 1 		0
																					//TS0 IE0 END0 D0  	
	
	ADC0->IM					= (1U<<3);		//SS3 Interrupt masked
	
	ADC0->ACTSS 			|= (1U<<3);		//Enable Sample Sequencer 3 (SS3)	(Step 7)	

}

